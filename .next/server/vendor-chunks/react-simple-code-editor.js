"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-simple-code-editor";
exports.ids = ["vendor-chunks/react-simple-code-editor"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-simple-code-editor/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/react-simple-code-editor/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __extends = (void 0) && (void 0).__extends || function() {\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf || ({\n            __proto__: []\n        }) instanceof Array && function(d, b) {\n            d.__proto__ = b;\n        } || function(d, b) {\n            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n        };\n        return extendStatics(d, b);\n    };\n    return function(d, b) {\n        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar __assign = (void 0) && (void 0).__assign || function() {\n    __assign = Object.assign || function(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __rest = (void 0) && (void 0).__rest || function(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __importStar(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\nvar KEYCODE_ENTER = 13;\nvar KEYCODE_TAB = 9;\nvar KEYCODE_BACKSPACE = 8;\nvar KEYCODE_Y = 89;\nvar KEYCODE_Z = 90;\nvar KEYCODE_M = 77;\nvar KEYCODE_PARENS = 57;\nvar KEYCODE_BRACKETS = 219;\nvar KEYCODE_QUOTE = 222;\nvar KEYCODE_BACK_QUOTE = 192;\nvar KEYCODE_ESCAPE = 27;\nvar HISTORY_LIMIT = 100;\nvar HISTORY_TIME_GAP = 3000;\nvar isWindows =  false && 0;\nvar isMacLike =  false && 0;\nvar className = \"npm__react-simple-code-editor__textarea\";\nvar cssText = /* CSS */ \"\\n/**\\n * Reset the text fill color so that placeholder is visible\\n */\\n.\".concat(className, \":empty {\\n  -webkit-text-fill-color: inherit !important;\\n}\\n\\n/**\\n * Hack to apply on some CSS on IE10 and IE11\\n */\\n@media all and (-ms-high-contrast: none), (-ms-high-contrast: active) {\\n  /**\\n    * IE doesn't support '-webkit-text-fill-color'\\n    * So we use 'color: transparent' to make the text transparent on IE\\n    * Unlike other browsers, it doesn't affect caret color in IE\\n    */\\n  .\").concat(className, \" {\\n    color: transparent !important;\\n  }\\n\\n  .\").concat(className, \"::selection {\\n    background-color: #accef7 !important;\\n    color: transparent !important;\\n  }\\n}\\n\");\nvar Editor = /** @class */ function(_super) {\n    __extends(Editor, _super);\n    function Editor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            capture: true\n        };\n        _this._recordCurrentState = function() {\n            var input = _this._input;\n            if (!input) return;\n            // Save current state of the input\n            var value = input.value, selectionStart = input.selectionStart, selectionEnd = input.selectionEnd;\n            _this._recordChange({\n                value: value,\n                selectionStart: selectionStart,\n                selectionEnd: selectionEnd\n            });\n        };\n        _this._getLines = function(text, position) {\n            return text.substring(0, position).split(\"\\n\");\n        };\n        _this._recordChange = function(record, overwrite) {\n            var _a, _b, _c;\n            if (overwrite === void 0) {\n                overwrite = false;\n            }\n            var _d = _this._history, stack = _d.stack, offset = _d.offset;\n            if (stack.length && offset > -1) {\n                // When something updates, drop the redo operations\n                _this._history.stack = stack.slice(0, offset + 1);\n                // Limit the number of operations to 100\n                var count = _this._history.stack.length;\n                if (count > HISTORY_LIMIT) {\n                    var extras = count - HISTORY_LIMIT;\n                    _this._history.stack = stack.slice(extras, count);\n                    _this._history.offset = Math.max(_this._history.offset - extras, 0);\n                }\n            }\n            var timestamp = Date.now();\n            if (overwrite) {\n                var last = _this._history.stack[_this._history.offset];\n                if (last && timestamp - last.timestamp < HISTORY_TIME_GAP) {\n                    // A previous entry exists and was in short interval\n                    // Match the last word in the line\n                    var re = /[^a-z0-9]([a-z0-9]+)$/i;\n                    // Get the previous line\n                    var previous = (_a = _this._getLines(last.value, last.selectionStart).pop()) === null || _a === void 0 ? void 0 : _a.match(re);\n                    // Get the current line\n                    var current = (_b = _this._getLines(record.value, record.selectionStart).pop()) === null || _b === void 0 ? void 0 : _b.match(re);\n                    if ((previous === null || previous === void 0 ? void 0 : previous[1]) && ((_c = current === null || current === void 0 ? void 0 : current[1]) === null || _c === void 0 ? void 0 : _c.startsWith(previous[1]))) {\n                        // The last word of the previous line and current line match\n                        // Overwrite previous entry so that undo will remove whole word\n                        _this._history.stack[_this._history.offset] = __assign(__assign({}, record), {\n                            timestamp: timestamp\n                        });\n                        return;\n                    }\n                }\n            }\n            // Add the new operation to the stack\n            _this._history.stack.push(__assign(__assign({}, record), {\n                timestamp: timestamp\n            }));\n            _this._history.offset++;\n        };\n        _this._updateInput = function(record) {\n            var input = _this._input;\n            if (!input) return;\n            // Update values and selection state\n            input.value = record.value;\n            input.selectionStart = record.selectionStart;\n            input.selectionEnd = record.selectionEnd;\n            _this.props.onValueChange(record.value);\n        };\n        _this._applyEdits = function(record) {\n            // Save last selection state\n            var input = _this._input;\n            var last = _this._history.stack[_this._history.offset];\n            if (last && input) {\n                _this._history.stack[_this._history.offset] = __assign(__assign({}, last), {\n                    selectionStart: input.selectionStart,\n                    selectionEnd: input.selectionEnd\n                });\n            }\n            // Save the changes\n            _this._recordChange(record);\n            _this._updateInput(record);\n        };\n        _this._undoEdit = function() {\n            var _a = _this._history, stack = _a.stack, offset = _a.offset;\n            // Get the previous edit\n            var record = stack[offset - 1];\n            if (record) {\n                // Apply the changes and update the offset\n                _this._updateInput(record);\n                _this._history.offset = Math.max(offset - 1, 0);\n            }\n        };\n        _this._redoEdit = function() {\n            var _a = _this._history, stack = _a.stack, offset = _a.offset;\n            // Get the next edit\n            var record = stack[offset + 1];\n            if (record) {\n                // Apply the changes and update the offset\n                _this._updateInput(record);\n                _this._history.offset = Math.min(offset + 1, stack.length - 1);\n            }\n        };\n        _this._handleKeyDown = function(e) {\n            var _a = _this.props, tabSize = _a.tabSize, insertSpaces = _a.insertSpaces, ignoreTabKey = _a.ignoreTabKey, onKeyDown = _a.onKeyDown;\n            if (onKeyDown) {\n                onKeyDown(e);\n                if (e.defaultPrevented) {\n                    return;\n                }\n            }\n            if (e.keyCode === KEYCODE_ESCAPE) {\n                e.currentTarget.blur();\n            }\n            var _b = e.currentTarget, value = _b.value, selectionStart = _b.selectionStart, selectionEnd = _b.selectionEnd;\n            var tabCharacter = (insertSpaces ? \" \" : \"\t\").repeat(tabSize);\n            if (e.keyCode === KEYCODE_TAB && !ignoreTabKey && _this.state.capture) {\n                // Prevent focus change\n                e.preventDefault();\n                if (e.shiftKey) {\n                    // Unindent selected lines\n                    var linesBeforeCaret = _this._getLines(value, selectionStart);\n                    var startLine_1 = linesBeforeCaret.length - 1;\n                    var endLine_1 = _this._getLines(value, selectionEnd).length - 1;\n                    var nextValue = value.split(\"\\n\").map(function(line, i) {\n                        if (i >= startLine_1 && i <= endLine_1 && line.startsWith(tabCharacter)) {\n                            return line.substring(tabCharacter.length);\n                        }\n                        return line;\n                    }).join(\"\\n\");\n                    if (value !== nextValue) {\n                        var startLineText = linesBeforeCaret[startLine_1];\n                        _this._applyEdits({\n                            value: nextValue,\n                            // Move the start cursor if first line in selection was modified\n                            // It was modified only if it started with a tab\n                            selectionStart: (startLineText === null || startLineText === void 0 ? void 0 : startLineText.startsWith(tabCharacter)) ? selectionStart - tabCharacter.length : selectionStart,\n                            // Move the end cursor by total number of characters removed\n                            selectionEnd: selectionEnd - (value.length - nextValue.length)\n                        });\n                    }\n                } else if (selectionStart !== selectionEnd) {\n                    // Indent selected lines\n                    var linesBeforeCaret = _this._getLines(value, selectionStart);\n                    var startLine_2 = linesBeforeCaret.length - 1;\n                    var endLine_2 = _this._getLines(value, selectionEnd).length - 1;\n                    var startLineText = linesBeforeCaret[startLine_2];\n                    _this._applyEdits({\n                        value: value.split(\"\\n\").map(function(line, i) {\n                            if (i >= startLine_2 && i <= endLine_2) {\n                                return tabCharacter + line;\n                            }\n                            return line;\n                        }).join(\"\\n\"),\n                        // Move the start cursor by number of characters added in first line of selection\n                        // Don't move it if it there was no text before cursor\n                        selectionStart: startLineText && /\\S/.test(startLineText) ? selectionStart + tabCharacter.length : selectionStart,\n                        // Move the end cursor by total number of characters added\n                        selectionEnd: selectionEnd + tabCharacter.length * (endLine_2 - startLine_2 + 1)\n                    });\n                } else {\n                    var updatedSelection = selectionStart + tabCharacter.length;\n                    _this._applyEdits({\n                        // Insert tab character at caret\n                        value: value.substring(0, selectionStart) + tabCharacter + value.substring(selectionEnd),\n                        // Update caret position\n                        selectionStart: updatedSelection,\n                        selectionEnd: updatedSelection\n                    });\n                }\n            } else if (e.keyCode === KEYCODE_BACKSPACE) {\n                var hasSelection = selectionStart !== selectionEnd;\n                var textBeforeCaret = value.substring(0, selectionStart);\n                if (textBeforeCaret.endsWith(tabCharacter) && !hasSelection) {\n                    // Prevent default delete behaviour\n                    e.preventDefault();\n                    var updatedSelection = selectionStart - tabCharacter.length;\n                    _this._applyEdits({\n                        // Remove tab character at caret\n                        value: value.substring(0, selectionStart - tabCharacter.length) + value.substring(selectionEnd),\n                        // Update caret position\n                        selectionStart: updatedSelection,\n                        selectionEnd: updatedSelection\n                    });\n                }\n            } else if (e.keyCode === KEYCODE_ENTER) {\n                // Ignore selections\n                if (selectionStart === selectionEnd) {\n                    // Get the current line\n                    var line = _this._getLines(value, selectionStart).pop();\n                    var matches = line === null || line === void 0 ? void 0 : line.match(/^\\s+/);\n                    if (matches === null || matches === void 0 ? void 0 : matches[0]) {\n                        e.preventDefault();\n                        // Preserve indentation on inserting a new line\n                        var indent = \"\\n\" + matches[0];\n                        var updatedSelection = selectionStart + indent.length;\n                        _this._applyEdits({\n                            // Insert indentation character at caret\n                            value: value.substring(0, selectionStart) + indent + value.substring(selectionEnd),\n                            // Update caret position\n                            selectionStart: updatedSelection,\n                            selectionEnd: updatedSelection\n                        });\n                    }\n                }\n            } else if (e.keyCode === KEYCODE_PARENS || e.keyCode === KEYCODE_BRACKETS || e.keyCode === KEYCODE_QUOTE || e.keyCode === KEYCODE_BACK_QUOTE) {\n                var chars = void 0;\n                if (e.keyCode === KEYCODE_PARENS && e.shiftKey) {\n                    chars = [\n                        \"(\",\n                        \")\"\n                    ];\n                } else if (e.keyCode === KEYCODE_BRACKETS) {\n                    if (e.shiftKey) {\n                        chars = [\n                            \"{\",\n                            \"}\"\n                        ];\n                    } else {\n                        chars = [\n                            \"[\",\n                            \"]\"\n                        ];\n                    }\n                } else if (e.keyCode === KEYCODE_QUOTE) {\n                    if (e.shiftKey) {\n                        chars = [\n                            '\"',\n                            '\"'\n                        ];\n                    } else {\n                        chars = [\n                            \"'\",\n                            \"'\"\n                        ];\n                    }\n                } else if (e.keyCode === KEYCODE_BACK_QUOTE && !e.shiftKey) {\n                    chars = [\n                        \"`\",\n                        \"`\"\n                    ];\n                }\n                // If text is selected, wrap them in the characters\n                if (selectionStart !== selectionEnd && chars) {\n                    e.preventDefault();\n                    _this._applyEdits({\n                        value: value.substring(0, selectionStart) + chars[0] + value.substring(selectionStart, selectionEnd) + chars[1] + value.substring(selectionEnd),\n                        // Update caret position\n                        selectionStart: selectionStart,\n                        selectionEnd: selectionEnd + 2\n                    });\n                }\n            } else if ((isMacLike ? e.metaKey && e.keyCode === KEYCODE_Z : e.ctrlKey && e.keyCode === KEYCODE_Z) && !e.shiftKey && !e.altKey) {\n                e.preventDefault();\n                _this._undoEdit();\n            } else if ((isMacLike ? e.metaKey && e.keyCode === KEYCODE_Z && e.shiftKey : isWindows ? e.ctrlKey && e.keyCode === KEYCODE_Y : e.ctrlKey && e.keyCode === KEYCODE_Z && e.shiftKey) && !e.altKey) {\n                e.preventDefault();\n                _this._redoEdit();\n            } else if (e.keyCode === KEYCODE_M && e.ctrlKey && (isMacLike ? e.shiftKey : true)) {\n                e.preventDefault();\n                // Toggle capturing tab key so users can focus away\n                _this.setState(function(state) {\n                    return {\n                        capture: !state.capture\n                    };\n                });\n            }\n        };\n        _this._handleChange = function(e) {\n            var _a = e.currentTarget, value = _a.value, selectionStart = _a.selectionStart, selectionEnd = _a.selectionEnd;\n            _this._recordChange({\n                value: value,\n                selectionStart: selectionStart,\n                selectionEnd: selectionEnd\n            }, true);\n            _this.props.onValueChange(value);\n        };\n        _this._history = {\n            stack: [],\n            offset: -1\n        };\n        _this._input = null;\n        return _this;\n    }\n    Editor.prototype.componentDidMount = function() {\n        this._recordCurrentState();\n    };\n    Object.defineProperty(Editor.prototype, \"session\", {\n        get: function() {\n            return {\n                history: this._history\n            };\n        },\n        set: function(session) {\n            this._history = session.history;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Editor.prototype.render = function() {\n        var _this = this;\n        var _a = this.props, value = _a.value, style = _a.style, padding = _a.padding, highlight = _a.highlight, textareaId = _a.textareaId, textareaClassName = _a.textareaClassName, autoFocus = _a.autoFocus, disabled = _a.disabled, form = _a.form, maxLength = _a.maxLength, minLength = _a.minLength, name = _a.name, placeholder = _a.placeholder, readOnly = _a.readOnly, required = _a.required, onClick = _a.onClick, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyUp = _a.onKeyUp, /* eslint-disable @typescript-eslint/no-unused-vars */ onKeyDown = _a.onKeyDown, onValueChange = _a.onValueChange, tabSize = _a.tabSize, insertSpaces = _a.insertSpaces, ignoreTabKey = _a.ignoreTabKey, /* eslint-enable @typescript-eslint/no-unused-vars */ preClassName = _a.preClassName, rest = __rest(_a, [\n            \"value\",\n            \"style\",\n            \"padding\",\n            \"highlight\",\n            \"textareaId\",\n            \"textareaClassName\",\n            \"autoFocus\",\n            \"disabled\",\n            \"form\",\n            \"maxLength\",\n            \"minLength\",\n            \"name\",\n            \"placeholder\",\n            \"readOnly\",\n            \"required\",\n            \"onClick\",\n            \"onFocus\",\n            \"onBlur\",\n            \"onKeyUp\",\n            \"onKeyDown\",\n            \"onValueChange\",\n            \"tabSize\",\n            \"insertSpaces\",\n            \"ignoreTabKey\",\n            \"preClassName\"\n        ]);\n        var contentStyle = {\n            paddingTop: typeof padding === \"object\" ? padding.top : padding,\n            paddingRight: typeof padding === \"object\" ? padding.right : padding,\n            paddingBottom: typeof padding === \"object\" ? padding.bottom : padding,\n            paddingLeft: typeof padding === \"object\" ? padding.left : padding\n        };\n        var highlighted = highlight(value);\n        return React.createElement(\"div\", __assign({}, rest, {\n            style: __assign(__assign({}, styles.container), style)\n        }), React.createElement(\"pre\", __assign({\n            className: preClassName,\n            \"aria-hidden\": \"true\",\n            style: __assign(__assign(__assign({}, styles.editor), styles.highlight), contentStyle)\n        }, typeof highlighted === \"string\" ? {\n            dangerouslySetInnerHTML: {\n                __html: highlighted + \"<br />\"\n            }\n        } : {\n            children: highlighted\n        })), React.createElement(\"textarea\", {\n            ref: function(c) {\n                return _this._input = c;\n            },\n            style: __assign(__assign(__assign({}, styles.editor), styles.textarea), contentStyle),\n            className: className + (textareaClassName ? \" \".concat(textareaClassName) : \"\"),\n            id: textareaId,\n            value: value,\n            onChange: this._handleChange,\n            onKeyDown: this._handleKeyDown,\n            onClick: onClick,\n            onKeyUp: onKeyUp,\n            onFocus: onFocus,\n            onBlur: onBlur,\n            disabled: disabled,\n            form: form,\n            maxLength: maxLength,\n            minLength: minLength,\n            name: name,\n            placeholder: placeholder,\n            readOnly: readOnly,\n            required: required,\n            autoFocus: autoFocus,\n            autoCapitalize: \"off\",\n            autoComplete: \"off\",\n            autoCorrect: \"off\",\n            spellCheck: false,\n            \"data-gramm\": false\n        }), React.createElement(\"style\", {\n            dangerouslySetInnerHTML: {\n                __html: cssText\n            }\n        }));\n    };\n    Editor.defaultProps = {\n        tabSize: 2,\n        insertSpaces: true,\n        ignoreTabKey: false,\n        padding: 0\n    };\n    return Editor;\n}(React.Component);\nexports[\"default\"] = Editor;\nvar styles = {\n    container: {\n        position: \"relative\",\n        textAlign: \"left\",\n        boxSizing: \"border-box\",\n        padding: 0,\n        overflow: \"hidden\"\n    },\n    textarea: {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        height: \"100%\",\n        width: \"100%\",\n        resize: \"none\",\n        color: \"inherit\",\n        overflow: \"hidden\",\n        MozOsxFontSmoothing: \"grayscale\",\n        WebkitFontSmoothing: \"antialiased\",\n        WebkitTextFillColor: \"transparent\"\n    },\n    highlight: {\n        position: \"relative\",\n        pointerEvents: \"none\"\n    },\n    editor: {\n        margin: 0,\n        border: 0,\n        background: \"none\",\n        boxSizing: \"inherit\",\n        display: \"inherit\",\n        fontFamily: \"inherit\",\n        fontSize: \"inherit\",\n        fontStyle: \"inherit\",\n        fontVariantLigatures: \"inherit\",\n        fontWeight: \"inherit\",\n        letterSpacing: \"inherit\",\n        lineHeight: \"inherit\",\n        tabSize: \"inherit\",\n        textIndent: \"inherit\",\n        textRendering: \"inherit\",\n        textTransform: \"inherit\",\n        whiteSpace: \"pre-wrap\",\n        wordBreak: \"keep-all\",\n        overflowWrap: \"break-word\"\n    }\n}; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2ltcGxlLWNvZGUtZWRpdG9yL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVksQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxTQUFTLElBQUs7SUFDeEMsSUFBSUMsZ0JBQWdCLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztRQUM5QkYsZ0JBQWdCRyxPQUFPQyxjQUFjLElBQ2hDO1lBQUVDLFdBQVcsRUFBRTtRQUFDLGNBQWFDLFNBQVMsU0FBVUwsQ0FBQyxFQUFFQyxDQUFDO1lBQUlELEVBQUVJLFNBQVMsR0FBR0g7UUFBRyxLQUMxRSxTQUFVRCxDQUFDLEVBQUVDLENBQUM7WUFBSSxJQUFLLElBQUlLLEtBQUtMLEVBQUcsSUFBSUMsT0FBT0ssU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsR0FBR0ssSUFBSU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtRQUFFO1FBQ3BHLE9BQU9QLGNBQWNDLEdBQUdDO0lBQzVCO0lBQ0EsT0FBTyxTQUFVRCxDQUFDLEVBQUVDLENBQUM7UUFDakIsSUFBSSxPQUFPQSxNQUFNLGNBQWNBLE1BQU0sTUFDakMsTUFBTSxJQUFJUyxVQUFVLHlCQUF5QkMsT0FBT1YsS0FBSztRQUM3REYsY0FBY0MsR0FBR0M7UUFDakIsU0FBU1c7WUFBTyxJQUFJLENBQUNDLFdBQVcsR0FBR2I7UUFBRztRQUN0Q0EsRUFBRU8sU0FBUyxHQUFHTixNQUFNLE9BQU9DLE9BQU9ZLE1BQU0sQ0FBQ2IsS0FBTVcsQ0FBQUEsR0FBR0wsU0FBUyxHQUFHTixFQUFFTSxTQUFTLEVBQUUsSUFBSUssSUFBRztJQUN0RjtBQUNKO0FBQ0EsSUFBSUcsV0FBVyxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFFBQVEsSUFBSztJQUN0Q0EsV0FBV2IsT0FBT2MsTUFBTSxJQUFJLFNBQVNDLENBQUM7UUFDbEMsSUFBSyxJQUFJQyxHQUFHQyxJQUFJLEdBQUdDLElBQUlDLFVBQVVDLE1BQU0sRUFBRUgsSUFBSUMsR0FBR0QsSUFBSztZQUNqREQsSUFBSUcsU0FBUyxDQUFDRixFQUFFO1lBQ2hCLElBQUssSUFBSWIsS0FBS1ksRUFBRyxJQUFJaEIsT0FBT0ssU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1MsR0FBR1osSUFDekRXLENBQUMsQ0FBQ1gsRUFBRSxHQUFHWSxDQUFDLENBQUNaLEVBQUU7UUFDbkI7UUFDQSxPQUFPVztJQUNYO0lBQ0EsT0FBT0YsU0FBU1EsS0FBSyxDQUFDLElBQUksRUFBRUY7QUFDaEM7QUFDQSxJQUFJRyxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU10QixDQUFBQSxPQUFPWSxNQUFNLEdBQUksU0FBU1csQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPNUIsT0FBTzZCLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0F6QixPQUFPbUMsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNcEMsQ0FBQUEsT0FBT1ksTUFBTSxHQUFJLFNBQVNXLENBQUMsRUFBRWMsQ0FBQztJQUN6RnJDLE9BQU9tQyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVVDLEdBQUc7SUFDM0QsSUFBSUEsT0FBT0EsSUFBSVYsVUFBVSxFQUFFLE9BQU9VO0lBQ2xDLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUlELE9BQU8sTUFBTTtRQUFBLElBQUssSUFBSWYsS0FBS2UsSUFBSyxJQUFJZixNQUFNLGFBQWF6QixPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDaUMsS0FBS2YsSUFBSUgsZ0JBQWdCbUIsUUFBUUQsS0FBS2Y7SUFBRTtJQUN4SVcsbUJBQW1CSyxRQUFRRDtJQUMzQixPQUFPQztBQUNYO0FBQ0EsSUFBSUMsU0FBUyxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLE1BQU0sSUFBSyxTQUFVMUIsQ0FBQyxFQUFFMkIsQ0FBQztJQUNoRCxJQUFJNUIsSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJWCxLQUFLWSxFQUFHLElBQUloQixPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUyxHQUFHWixNQUFNdUMsRUFBRUMsT0FBTyxDQUFDeEMsS0FBSyxHQUM5RVcsQ0FBQyxDQUFDWCxFQUFFLEdBQUdZLENBQUMsQ0FBQ1osRUFBRTtJQUNmLElBQUlZLEtBQUssUUFBUSxPQUFPaEIsT0FBTzZDLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSTVCLElBQUksR0FBR2IsSUFBSUosT0FBTzZDLHFCQUFxQixDQUFDN0IsSUFBSUMsSUFBSWIsRUFBRWdCLE1BQU0sRUFBRUgsSUFBSztRQUNwRSxJQUFJMEIsRUFBRUMsT0FBTyxDQUFDeEMsQ0FBQyxDQUFDYSxFQUFFLElBQUksS0FBS2pCLE9BQU9LLFNBQVMsQ0FBQ3lDLG9CQUFvQixDQUFDdkMsSUFBSSxDQUFDUyxHQUFHWixDQUFDLENBQUNhLEVBQUUsR0FDekVGLENBQUMsQ0FBQ1gsQ0FBQyxDQUFDYSxFQUFFLENBQUMsR0FBR0QsQ0FBQyxDQUFDWixDQUFDLENBQUNhLEVBQUUsQ0FBQztJQUN6QjtJQUNKLE9BQU9GO0FBQ1g7QUFDQWYsOENBQTZDO0lBQUVzQyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELElBQUlVLFFBQVFULGFBQWFVLG1CQUFPQSxDQUFDLHdHQUFPO0FBQ3hDLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLG9CQUFvQjtBQUN4QixJQUFJQyxZQUFZO0FBQ2hCLElBQUlDLFlBQVk7QUFDaEIsSUFBSUMsWUFBWTtBQUNoQixJQUFJQyxpQkFBaUI7QUFDckIsSUFBSUMsbUJBQW1CO0FBQ3ZCLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxxQkFBcUI7QUFDekIsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxtQkFBbUI7QUFDdkIsSUFBSUMsWUFBWSxNQUNTQyxJQUNyQixDQUErQjtBQUNuQyxJQUFJSSxZQUFZLE1BQ1NKLElBQ3JCLENBQWtEO0FBQ3RELElBQUlLLFlBQVk7QUFDaEIsSUFBSUMsVUFBVSxPQUFPLEdBQUcsNkVBQTZFQyxNQUFNLENBQUNGLFdBQVcsc1pBQXNaRSxNQUFNLENBQUNGLFdBQVcsc0RBQXNERSxNQUFNLENBQUNGLFdBQVc7QUFDdm1CLElBQUlHLFNBQVMsV0FBVyxHQUFJLFNBQVVDLE1BQU07SUFDeEM3RSxVQUFVNEUsUUFBUUM7SUFDbEIsU0FBU0Q7UUFDTCxJQUFJRSxRQUFRRCxXQUFXLFFBQVFBLE9BQU9wRCxLQUFLLENBQUMsSUFBSSxFQUFFRixjQUFjLElBQUk7UUFDcEV1RCxNQUFNQyxLQUFLLEdBQUc7WUFDVkMsU0FBUztRQUNiO1FBQ0FGLE1BQU1HLG1CQUFtQixHQUFHO1lBQ3hCLElBQUlDLFFBQVFKLE1BQU1LLE1BQU07WUFDeEIsSUFBSSxDQUFDRCxPQUNEO1lBQ0osa0NBQWtDO1lBQ2xDLElBQUl4QyxRQUFRd0MsTUFBTXhDLEtBQUssRUFBRTBDLGlCQUFpQkYsTUFBTUUsY0FBYyxFQUFFQyxlQUFlSCxNQUFNRyxZQUFZO1lBQ2pHUCxNQUFNUSxhQUFhLENBQUM7Z0JBQ2hCNUMsT0FBT0E7Z0JBQ1AwQyxnQkFBZ0JBO2dCQUNoQkMsY0FBY0E7WUFDbEI7UUFDSjtRQUNBUCxNQUFNUyxTQUFTLEdBQUcsU0FBVUMsSUFBSSxFQUFFQyxRQUFRO1lBQ3RDLE9BQU9ELEtBQUtFLFNBQVMsQ0FBQyxHQUFHRCxVQUFVRSxLQUFLLENBQUM7UUFDN0M7UUFDQWIsTUFBTVEsYUFBYSxHQUFHLFNBQVVNLE1BQU0sRUFBRUMsU0FBUztZQUM3QyxJQUFJQyxJQUFJQyxJQUFJQztZQUNaLElBQUlILGNBQWMsS0FBSyxHQUFHO2dCQUFFQSxZQUFZO1lBQU87WUFDL0MsSUFBSUksS0FBS25CLE1BQU1vQixRQUFRLEVBQUVDLFFBQVFGLEdBQUdFLEtBQUssRUFBRUMsU0FBU0gsR0FBR0csTUFBTTtZQUM3RCxJQUFJRCxNQUFNM0UsTUFBTSxJQUFJNEUsU0FBUyxDQUFDLEdBQUc7Z0JBQzdCLG1EQUFtRDtnQkFDbkR0QixNQUFNb0IsUUFBUSxDQUFDQyxLQUFLLEdBQUdBLE1BQU1FLEtBQUssQ0FBQyxHQUFHRCxTQUFTO2dCQUMvQyx3Q0FBd0M7Z0JBQ3hDLElBQUlFLFFBQVF4QixNQUFNb0IsUUFBUSxDQUFDQyxLQUFLLENBQUMzRSxNQUFNO2dCQUN2QyxJQUFJOEUsUUFBUXJDLGVBQWU7b0JBQ3ZCLElBQUlzQyxTQUFTRCxRQUFRckM7b0JBQ3JCYSxNQUFNb0IsUUFBUSxDQUFDQyxLQUFLLEdBQUdBLE1BQU1FLEtBQUssQ0FBQ0UsUUFBUUQ7b0JBQzNDeEIsTUFBTW9CLFFBQVEsQ0FBQ0UsTUFBTSxHQUFHSSxLQUFLQyxHQUFHLENBQUMzQixNQUFNb0IsUUFBUSxDQUFDRSxNQUFNLEdBQUdHLFFBQVE7Z0JBQ3JFO1lBQ0o7WUFDQSxJQUFJRyxZQUFZQyxLQUFLQyxHQUFHO1lBQ3hCLElBQUlmLFdBQVc7Z0JBQ1gsSUFBSWdCLE9BQU8vQixNQUFNb0IsUUFBUSxDQUFDQyxLQUFLLENBQUNyQixNQUFNb0IsUUFBUSxDQUFDRSxNQUFNLENBQUM7Z0JBQ3RELElBQUlTLFFBQVFILFlBQVlHLEtBQUtILFNBQVMsR0FBR3hDLGtCQUFrQjtvQkFDdkQsb0RBQW9EO29CQUNwRCxrQ0FBa0M7b0JBQ2xDLElBQUk0QyxLQUFLO29CQUNULHdCQUF3QjtvQkFDeEIsSUFBSUMsV0FBVyxDQUFDakIsS0FBS2hCLE1BQU1TLFNBQVMsQ0FBQ3NCLEtBQUtuRSxLQUFLLEVBQUVtRSxLQUFLekIsY0FBYyxFQUMvRDRCLEdBQUcsRUFBQyxNQUFPLFFBQVFsQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdtQixLQUFLLENBQUNIO29CQUMxRCx1QkFBdUI7b0JBQ3ZCLElBQUlJLFVBQVUsQ0FBQ25CLEtBQUtqQixNQUFNUyxTQUFTLENBQUNLLE9BQU9sRCxLQUFLLEVBQUVrRCxPQUFPUixjQUFjLEVBQ2xFNEIsR0FBRyxFQUFDLE1BQU8sUUFBUWpCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tCLEtBQUssQ0FBQ0g7b0JBQzFELElBQUksQ0FBQ0MsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVEsQ0FBQyxFQUFFLEtBQU0sRUFBQ2YsS0FBS2tCLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPLENBQUMsRUFBRSxNQUFNLFFBQVFsQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdtQixVQUFVLENBQUNKLFFBQVEsQ0FBQyxFQUFFLElBQUk7d0JBQzVNLDREQUE0RDt3QkFDNUQsK0RBQStEO3dCQUMvRGpDLE1BQU1vQixRQUFRLENBQUNDLEtBQUssQ0FBQ3JCLE1BQU1vQixRQUFRLENBQUNFLE1BQU0sQ0FBQyxHQUFHbkYsU0FBU0EsU0FBUyxDQUFDLEdBQUcyRSxTQUFTOzRCQUFFYyxXQUFXQTt3QkFBVTt3QkFDcEc7b0JBQ0o7Z0JBQ0o7WUFDSjtZQUNBLHFDQUFxQztZQUNyQzVCLE1BQU1vQixRQUFRLENBQUNDLEtBQUssQ0FBQ2lCLElBQUksQ0FBQ25HLFNBQVNBLFNBQVMsQ0FBQyxHQUFHMkUsU0FBUztnQkFBRWMsV0FBV0E7WUFBVTtZQUNoRjVCLE1BQU1vQixRQUFRLENBQUNFLE1BQU07UUFDekI7UUFDQXRCLE1BQU11QyxZQUFZLEdBQUcsU0FBVXpCLE1BQU07WUFDakMsSUFBSVYsUUFBUUosTUFBTUssTUFBTTtZQUN4QixJQUFJLENBQUNELE9BQ0Q7WUFDSixvQ0FBb0M7WUFDcENBLE1BQU14QyxLQUFLLEdBQUdrRCxPQUFPbEQsS0FBSztZQUMxQndDLE1BQU1FLGNBQWMsR0FBR1EsT0FBT1IsY0FBYztZQUM1Q0YsTUFBTUcsWUFBWSxHQUFHTyxPQUFPUCxZQUFZO1lBQ3hDUCxNQUFNd0MsS0FBSyxDQUFDQyxhQUFhLENBQUMzQixPQUFPbEQsS0FBSztRQUMxQztRQUNBb0MsTUFBTTBDLFdBQVcsR0FBRyxTQUFVNUIsTUFBTTtZQUNoQyw0QkFBNEI7WUFDNUIsSUFBSVYsUUFBUUosTUFBTUssTUFBTTtZQUN4QixJQUFJMEIsT0FBTy9CLE1BQU1vQixRQUFRLENBQUNDLEtBQUssQ0FBQ3JCLE1BQU1vQixRQUFRLENBQUNFLE1BQU0sQ0FBQztZQUN0RCxJQUFJUyxRQUFRM0IsT0FBTztnQkFDZkosTUFBTW9CLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDckIsTUFBTW9CLFFBQVEsQ0FBQ0UsTUFBTSxDQUFDLEdBQUduRixTQUFTQSxTQUFTLENBQUMsR0FBRzRGLE9BQU87b0JBQUV6QixnQkFBZ0JGLE1BQU1FLGNBQWM7b0JBQUVDLGNBQWNILE1BQU1HLFlBQVk7Z0JBQUM7WUFDeEo7WUFDQSxtQkFBbUI7WUFDbkJQLE1BQU1RLGFBQWEsQ0FBQ007WUFDcEJkLE1BQU11QyxZQUFZLENBQUN6QjtRQUN2QjtRQUNBZCxNQUFNMkMsU0FBUyxHQUFHO1lBQ2QsSUFBSTNCLEtBQUtoQixNQUFNb0IsUUFBUSxFQUFFQyxRQUFRTCxHQUFHSyxLQUFLLEVBQUVDLFNBQVNOLEdBQUdNLE1BQU07WUFDN0Qsd0JBQXdCO1lBQ3hCLElBQUlSLFNBQVNPLEtBQUssQ0FBQ0MsU0FBUyxFQUFFO1lBQzlCLElBQUlSLFFBQVE7Z0JBQ1IsMENBQTBDO2dCQUMxQ2QsTUFBTXVDLFlBQVksQ0FBQ3pCO2dCQUNuQmQsTUFBTW9CLFFBQVEsQ0FBQ0UsTUFBTSxHQUFHSSxLQUFLQyxHQUFHLENBQUNMLFNBQVMsR0FBRztZQUNqRDtRQUNKO1FBQ0F0QixNQUFNNEMsU0FBUyxHQUFHO1lBQ2QsSUFBSTVCLEtBQUtoQixNQUFNb0IsUUFBUSxFQUFFQyxRQUFRTCxHQUFHSyxLQUFLLEVBQUVDLFNBQVNOLEdBQUdNLE1BQU07WUFDN0Qsb0JBQW9CO1lBQ3BCLElBQUlSLFNBQVNPLEtBQUssQ0FBQ0MsU0FBUyxFQUFFO1lBQzlCLElBQUlSLFFBQVE7Z0JBQ1IsMENBQTBDO2dCQUMxQ2QsTUFBTXVDLFlBQVksQ0FBQ3pCO2dCQUNuQmQsTUFBTW9CLFFBQVEsQ0FBQ0UsTUFBTSxHQUFHSSxLQUFLbUIsR0FBRyxDQUFDdkIsU0FBUyxHQUFHRCxNQUFNM0UsTUFBTSxHQUFHO1lBQ2hFO1FBQ0o7UUFDQXNELE1BQU04QyxjQUFjLEdBQUcsU0FBVTdFLENBQUM7WUFDOUIsSUFBSStDLEtBQUtoQixNQUFNd0MsS0FBSyxFQUFFTyxVQUFVL0IsR0FBRytCLE9BQU8sRUFBRUMsZUFBZWhDLEdBQUdnQyxZQUFZLEVBQUVDLGVBQWVqQyxHQUFHaUMsWUFBWSxFQUFFQyxZQUFZbEMsR0FBR2tDLFNBQVM7WUFDcEksSUFBSUEsV0FBVztnQkFDWEEsVUFBVWpGO2dCQUNWLElBQUlBLEVBQUVrRixnQkFBZ0IsRUFBRTtvQkFDcEI7Z0JBQ0o7WUFDSjtZQUNBLElBQUlsRixFQUFFbUYsT0FBTyxLQUFLbEUsZ0JBQWdCO2dCQUM5QmpCLEVBQUVvRixhQUFhLENBQUNDLElBQUk7WUFDeEI7WUFDQSxJQUFJckMsS0FBS2hELEVBQUVvRixhQUFhLEVBQUV6RixRQUFRcUQsR0FBR3JELEtBQUssRUFBRTBDLGlCQUFpQlcsR0FBR1gsY0FBYyxFQUFFQyxlQUFlVSxHQUFHVixZQUFZO1lBQzlHLElBQUlnRCxlQUFlLENBQUNQLGVBQWUsTUFBTSxHQUFHLEVBQUdRLE1BQU0sQ0FBQ1Q7WUFDdEQsSUFBSTlFLEVBQUVtRixPQUFPLEtBQUszRSxlQUFlLENBQUN3RSxnQkFBZ0JqRCxNQUFNQyxLQUFLLENBQUNDLE9BQU8sRUFBRTtnQkFDbkUsdUJBQXVCO2dCQUN2QmpDLEVBQUV3RixjQUFjO2dCQUNoQixJQUFJeEYsRUFBRXlGLFFBQVEsRUFBRTtvQkFDWiwwQkFBMEI7b0JBQzFCLElBQUlDLG1CQUFtQjNELE1BQU1TLFNBQVMsQ0FBQzdDLE9BQU8wQztvQkFDOUMsSUFBSXNELGNBQWNELGlCQUFpQmpILE1BQU0sR0FBRztvQkFDNUMsSUFBSW1ILFlBQVk3RCxNQUFNUyxTQUFTLENBQUM3QyxPQUFPMkMsY0FBYzdELE1BQU0sR0FBRztvQkFDOUQsSUFBSW9ILFlBQVlsRyxNQUNYaUQsS0FBSyxDQUFDLE1BQ05rRCxHQUFHLENBQUMsU0FBVUMsSUFBSSxFQUFFekgsQ0FBQzt3QkFDdEIsSUFBSUEsS0FBS3FILGVBQ0xySCxLQUFLc0gsYUFDTEcsS0FBSzNCLFVBQVUsQ0FBQ2tCLGVBQWU7NEJBQy9CLE9BQU9TLEtBQUtwRCxTQUFTLENBQUMyQyxhQUFhN0csTUFBTTt3QkFDN0M7d0JBQ0EsT0FBT3NIO29CQUNYLEdBQ0tDLElBQUksQ0FBQztvQkFDVixJQUFJckcsVUFBVWtHLFdBQVc7d0JBQ3JCLElBQUlJLGdCQUFnQlAsZ0JBQWdCLENBQUNDLFlBQVk7d0JBQ2pENUQsTUFBTTBDLFdBQVcsQ0FBQzs0QkFDZDlFLE9BQU9rRzs0QkFDUCxnRUFBZ0U7NEJBQ2hFLGdEQUFnRDs0QkFDaER4RCxnQkFBZ0IsQ0FBQzRELGtCQUFrQixRQUFRQSxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsY0FBYzdCLFVBQVUsQ0FBQ2tCLGFBQVksSUFDOUdqRCxpQkFBaUJpRCxhQUFhN0csTUFBTSxHQUNwQzREOzRCQUNOLDREQUE0RDs0QkFDNURDLGNBQWNBLGVBQWdCM0MsQ0FBQUEsTUFBTWxCLE1BQU0sR0FBR29ILFVBQVVwSCxNQUFNO3dCQUNqRTtvQkFDSjtnQkFDSixPQUNLLElBQUk0RCxtQkFBbUJDLGNBQWM7b0JBQ3RDLHdCQUF3QjtvQkFDeEIsSUFBSW9ELG1CQUFtQjNELE1BQU1TLFNBQVMsQ0FBQzdDLE9BQU8wQztvQkFDOUMsSUFBSTZELGNBQWNSLGlCQUFpQmpILE1BQU0sR0FBRztvQkFDNUMsSUFBSTBILFlBQVlwRSxNQUFNUyxTQUFTLENBQUM3QyxPQUFPMkMsY0FBYzdELE1BQU0sR0FBRztvQkFDOUQsSUFBSXdILGdCQUFnQlAsZ0JBQWdCLENBQUNRLFlBQVk7b0JBQ2pEbkUsTUFBTTBDLFdBQVcsQ0FBQzt3QkFDZDlFLE9BQU9BLE1BQ0ZpRCxLQUFLLENBQUMsTUFDTmtELEdBQUcsQ0FBQyxTQUFVQyxJQUFJLEVBQUV6SCxDQUFDOzRCQUN0QixJQUFJQSxLQUFLNEgsZUFBZTVILEtBQUs2SCxXQUFXO2dDQUNwQyxPQUFPYixlQUFlUzs0QkFDMUI7NEJBQ0EsT0FBT0E7d0JBQ1gsR0FDS0MsSUFBSSxDQUFDO3dCQUNWLGlGQUFpRjt3QkFDakYsc0RBQXNEO3dCQUN0RDNELGdCQUFnQjRELGlCQUFpQixLQUFLM0UsSUFBSSxDQUFDMkUsaUJBQ3JDNUQsaUJBQWlCaUQsYUFBYTdHLE1BQU0sR0FDcEM0RDt3QkFDTiwwREFBMEQ7d0JBQzFEQyxjQUFjQSxlQUFlZ0QsYUFBYTdHLE1BQU0sR0FBSTBILENBQUFBLFlBQVlELGNBQWM7b0JBQ2xGO2dCQUNKLE9BQ0s7b0JBQ0QsSUFBSUUsbUJBQW1CL0QsaUJBQWlCaUQsYUFBYTdHLE1BQU07b0JBQzNEc0QsTUFBTTBDLFdBQVcsQ0FBQzt3QkFDZCxnQ0FBZ0M7d0JBQ2hDOUUsT0FBT0EsTUFBTWdELFNBQVMsQ0FBQyxHQUFHTixrQkFDdEJpRCxlQUNBM0YsTUFBTWdELFNBQVMsQ0FBQ0w7d0JBQ3BCLHdCQUF3Qjt3QkFDeEJELGdCQUFnQitEO3dCQUNoQjlELGNBQWM4RDtvQkFDbEI7Z0JBQ0o7WUFDSixPQUNLLElBQUlwRyxFQUFFbUYsT0FBTyxLQUFLMUUsbUJBQW1CO2dCQUN0QyxJQUFJNEYsZUFBZWhFLG1CQUFtQkM7Z0JBQ3RDLElBQUlnRSxrQkFBa0IzRyxNQUFNZ0QsU0FBUyxDQUFDLEdBQUdOO2dCQUN6QyxJQUFJaUUsZ0JBQWdCQyxRQUFRLENBQUNqQixpQkFBaUIsQ0FBQ2UsY0FBYztvQkFDekQsbUNBQW1DO29CQUNuQ3JHLEVBQUV3RixjQUFjO29CQUNoQixJQUFJWSxtQkFBbUIvRCxpQkFBaUJpRCxhQUFhN0csTUFBTTtvQkFDM0RzRCxNQUFNMEMsV0FBVyxDQUFDO3dCQUNkLGdDQUFnQzt3QkFDaEM5RSxPQUFPQSxNQUFNZ0QsU0FBUyxDQUFDLEdBQUdOLGlCQUFpQmlELGFBQWE3RyxNQUFNLElBQzFEa0IsTUFBTWdELFNBQVMsQ0FBQ0w7d0JBQ3BCLHdCQUF3Qjt3QkFDeEJELGdCQUFnQitEO3dCQUNoQjlELGNBQWM4RDtvQkFDbEI7Z0JBQ0o7WUFDSixPQUNLLElBQUlwRyxFQUFFbUYsT0FBTyxLQUFLNUUsZUFBZTtnQkFDbEMsb0JBQW9CO2dCQUNwQixJQUFJOEIsbUJBQW1CQyxjQUFjO29CQUNqQyx1QkFBdUI7b0JBQ3ZCLElBQUl5RCxPQUFPaEUsTUFBTVMsU0FBUyxDQUFDN0MsT0FBTzBDLGdCQUFnQjRCLEdBQUc7b0JBQ3JELElBQUl1QyxVQUFVVCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBSzdCLEtBQUssQ0FBQztvQkFDckUsSUFBSXNDLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPLENBQUMsRUFBRSxFQUFFO3dCQUM5RHhHLEVBQUV3RixjQUFjO3dCQUNoQiwrQ0FBK0M7d0JBQy9DLElBQUlpQixTQUFTLE9BQU9ELE9BQU8sQ0FBQyxFQUFFO3dCQUM5QixJQUFJSixtQkFBbUIvRCxpQkFBaUJvRSxPQUFPaEksTUFBTTt3QkFDckRzRCxNQUFNMEMsV0FBVyxDQUFDOzRCQUNkLHdDQUF3Qzs0QkFDeEM5RSxPQUFPQSxNQUFNZ0QsU0FBUyxDQUFDLEdBQUdOLGtCQUN0Qm9FLFNBQ0E5RyxNQUFNZ0QsU0FBUyxDQUFDTDs0QkFDcEIsd0JBQXdCOzRCQUN4QkQsZ0JBQWdCK0Q7NEJBQ2hCOUQsY0FBYzhEO3dCQUNsQjtvQkFDSjtnQkFDSjtZQUNKLE9BQ0ssSUFBSXBHLEVBQUVtRixPQUFPLEtBQUt0RSxrQkFDbkJiLEVBQUVtRixPQUFPLEtBQUtyRSxvQkFDZGQsRUFBRW1GLE9BQU8sS0FBS3BFLGlCQUNkZixFQUFFbUYsT0FBTyxLQUFLbkUsb0JBQW9CO2dCQUNsQyxJQUFJMEYsUUFBUSxLQUFLO2dCQUNqQixJQUFJMUcsRUFBRW1GLE9BQU8sS0FBS3RFLGtCQUFrQmIsRUFBRXlGLFFBQVEsRUFBRTtvQkFDNUNpQixRQUFRO3dCQUFDO3dCQUFLO3FCQUFJO2dCQUN0QixPQUNLLElBQUkxRyxFQUFFbUYsT0FBTyxLQUFLckUsa0JBQWtCO29CQUNyQyxJQUFJZCxFQUFFeUYsUUFBUSxFQUFFO3dCQUNaaUIsUUFBUTs0QkFBQzs0QkFBSzt5QkFBSTtvQkFDdEIsT0FDSzt3QkFDREEsUUFBUTs0QkFBQzs0QkFBSzt5QkFBSTtvQkFDdEI7Z0JBQ0osT0FDSyxJQUFJMUcsRUFBRW1GLE9BQU8sS0FBS3BFLGVBQWU7b0JBQ2xDLElBQUlmLEVBQUV5RixRQUFRLEVBQUU7d0JBQ1ppQixRQUFROzRCQUFDOzRCQUFLO3lCQUFJO29CQUN0QixPQUNLO3dCQUNEQSxRQUFROzRCQUFDOzRCQUFLO3lCQUFJO29CQUN0QjtnQkFDSixPQUNLLElBQUkxRyxFQUFFbUYsT0FBTyxLQUFLbkUsc0JBQXNCLENBQUNoQixFQUFFeUYsUUFBUSxFQUFFO29CQUN0RGlCLFFBQVE7d0JBQUM7d0JBQUs7cUJBQUk7Z0JBQ3RCO2dCQUNBLG1EQUFtRDtnQkFDbkQsSUFBSXJFLG1CQUFtQkMsZ0JBQWdCb0UsT0FBTztvQkFDMUMxRyxFQUFFd0YsY0FBYztvQkFDaEJ6RCxNQUFNMEMsV0FBVyxDQUFDO3dCQUNkOUUsT0FBT0EsTUFBTWdELFNBQVMsQ0FBQyxHQUFHTixrQkFDdEJxRSxLQUFLLENBQUMsRUFBRSxHQUNSL0csTUFBTWdELFNBQVMsQ0FBQ04sZ0JBQWdCQyxnQkFDaENvRSxLQUFLLENBQUMsRUFBRSxHQUNSL0csTUFBTWdELFNBQVMsQ0FBQ0w7d0JBQ3BCLHdCQUF3Qjt3QkFDeEJELGdCQUFnQkE7d0JBQ2hCQyxjQUFjQSxlQUFlO29CQUNqQztnQkFDSjtZQUNKLE9BQ0ssSUFBSSxDQUFDYixZQUVGekIsRUFBRTJHLE9BQU8sSUFBSTNHLEVBQUVtRixPQUFPLEtBQUt4RSxZQUUzQlgsRUFBRTRHLE9BQU8sSUFBSTVHLEVBQUVtRixPQUFPLEtBQUt4RSxTQUFRLEtBQ3ZDLENBQUNYLEVBQUV5RixRQUFRLElBQ1gsQ0FBQ3pGLEVBQUU2RyxNQUFNLEVBQUU7Z0JBQ1g3RyxFQUFFd0YsY0FBYztnQkFDaEJ6RCxNQUFNMkMsU0FBUztZQUNuQixPQUNLLElBQUksQ0FBQ2pELFlBRUZ6QixFQUFFMkcsT0FBTyxJQUFJM0csRUFBRW1GLE9BQU8sS0FBS3hFLGFBQWFYLEVBQUV5RixRQUFRLEdBQ3BEckUsWUFFTXBCLEVBQUU0RyxPQUFPLElBQUk1RyxFQUFFbUYsT0FBTyxLQUFLekUsWUFFM0JWLEVBQUU0RyxPQUFPLElBQUk1RyxFQUFFbUYsT0FBTyxLQUFLeEUsYUFBYVgsRUFBRXlGLFFBQVEsS0FDMUQsQ0FBQ3pGLEVBQUU2RyxNQUFNLEVBQUU7Z0JBQ1g3RyxFQUFFd0YsY0FBYztnQkFDaEJ6RCxNQUFNNEMsU0FBUztZQUNuQixPQUNLLElBQUkzRSxFQUFFbUYsT0FBTyxLQUFLdkUsYUFDbkJaLEVBQUU0RyxPQUFPLElBQ1JuRixDQUFBQSxZQUFZekIsRUFBRXlGLFFBQVEsR0FBRyxJQUFHLEdBQUk7Z0JBQ2pDekYsRUFBRXdGLGNBQWM7Z0JBQ2hCLG1EQUFtRDtnQkFDbkR6RCxNQUFNK0UsUUFBUSxDQUFDLFNBQVU5RSxLQUFLO29CQUFJLE9BQVE7d0JBQ3RDQyxTQUFTLENBQUNELE1BQU1DLE9BQU87b0JBQzNCO2dCQUFJO1lBQ1I7UUFDSjtRQUNBRixNQUFNZ0YsYUFBYSxHQUFHLFNBQVUvRyxDQUFDO1lBQzdCLElBQUkrQyxLQUFLL0MsRUFBRW9GLGFBQWEsRUFBRXpGLFFBQVFvRCxHQUFHcEQsS0FBSyxFQUFFMEMsaUJBQWlCVSxHQUFHVixjQUFjLEVBQUVDLGVBQWVTLEdBQUdULFlBQVk7WUFDOUdQLE1BQU1RLGFBQWEsQ0FBQztnQkFDaEI1QyxPQUFPQTtnQkFDUDBDLGdCQUFnQkE7Z0JBQ2hCQyxjQUFjQTtZQUNsQixHQUFHO1lBQ0hQLE1BQU13QyxLQUFLLENBQUNDLGFBQWEsQ0FBQzdFO1FBQzlCO1FBQ0FvQyxNQUFNb0IsUUFBUSxHQUFHO1lBQ2JDLE9BQU8sRUFBRTtZQUNUQyxRQUFRLENBQUM7UUFDYjtRQUNBdEIsTUFBTUssTUFBTSxHQUFHO1FBQ2YsT0FBT0w7SUFDWDtJQUNBRixPQUFPbkUsU0FBUyxDQUFDc0osaUJBQWlCLEdBQUc7UUFDakMsSUFBSSxDQUFDOUUsbUJBQW1CO0lBQzVCO0lBQ0E3RSxPQUFPbUMsY0FBYyxDQUFDcUMsT0FBT25FLFNBQVMsRUFBRSxXQUFXO1FBQy9DNkIsS0FBSztZQUNELE9BQU87Z0JBQ0gwSCxTQUFTLElBQUksQ0FBQzlELFFBQVE7WUFDMUI7UUFDSjtRQUNBK0QsS0FBSyxTQUFVQyxPQUFPO1lBQ2xCLElBQUksQ0FBQ2hFLFFBQVEsR0FBR2dFLFFBQVFGLE9BQU87UUFDbkM7UUFDQTNILFlBQVk7UUFDWkQsY0FBYztJQUNsQjtJQUNBd0MsT0FBT25FLFNBQVMsQ0FBQzBKLE1BQU0sR0FBRztRQUN0QixJQUFJckYsUUFBUSxJQUFJO1FBQ2hCLElBQUlnQixLQUFLLElBQUksQ0FBQ3dCLEtBQUssRUFBRTVFLFFBQVFvRCxHQUFHcEQsS0FBSyxFQUFFMEgsUUFBUXRFLEdBQUdzRSxLQUFLLEVBQUVDLFVBQVV2RSxHQUFHdUUsT0FBTyxFQUFFQyxZQUFZeEUsR0FBR3dFLFNBQVMsRUFBRUMsYUFBYXpFLEdBQUd5RSxVQUFVLEVBQUVDLG9CQUFvQjFFLEdBQUcwRSxpQkFBaUIsRUFBRUMsWUFBWTNFLEdBQUcyRSxTQUFTLEVBQUVDLFdBQVc1RSxHQUFHNEUsUUFBUSxFQUFFQyxPQUFPN0UsR0FBRzZFLElBQUksRUFBRUMsWUFBWTlFLEdBQUc4RSxTQUFTLEVBQUVDLFlBQVkvRSxHQUFHK0UsU0FBUyxFQUFFQyxPQUFPaEYsR0FBR2dGLElBQUksRUFBRUMsY0FBY2pGLEdBQUdpRixXQUFXLEVBQUVDLFdBQVdsRixHQUFHa0YsUUFBUSxFQUFFQyxXQUFXbkYsR0FBR21GLFFBQVEsRUFBRUMsVUFBVXBGLEdBQUdvRixPQUFPLEVBQUVDLFVBQVVyRixHQUFHcUYsT0FBTyxFQUFFQyxTQUFTdEYsR0FBR3NGLE1BQU0sRUFBRUMsVUFBVXZGLEdBQUd1RixPQUFPLEVBQ3ZkLG9EQUFvRCxHQUNwRHJELFlBQVlsQyxHQUFHa0MsU0FBUyxFQUFFVCxnQkFBZ0J6QixHQUFHeUIsYUFBYSxFQUFFTSxVQUFVL0IsR0FBRytCLE9BQU8sRUFBRUMsZUFBZWhDLEdBQUdnQyxZQUFZLEVBQUVDLGVBQWVqQyxHQUFHaUMsWUFBWSxFQUNoSixtREFBbUQsR0FDbkR1RCxlQUFleEYsR0FBR3dGLFlBQVksRUFBRUMsT0FBT3pJLE9BQU9nRCxJQUFJO1lBQUM7WUFBUztZQUFTO1lBQVc7WUFBYTtZQUFjO1lBQXFCO1lBQWE7WUFBWTtZQUFRO1lBQWE7WUFBYTtZQUFRO1lBQWU7WUFBWTtZQUFZO1lBQVc7WUFBVztZQUFVO1lBQVc7WUFBYTtZQUFpQjtZQUFXO1lBQWdCO1lBQWdCO1NBQWU7UUFDN1csSUFBSTBGLGVBQWU7WUFDZkMsWUFBWSxPQUFPcEIsWUFBWSxXQUFXQSxRQUFRcUIsR0FBRyxHQUFHckI7WUFDeERzQixjQUFjLE9BQU90QixZQUFZLFdBQVdBLFFBQVF1QixLQUFLLEdBQUd2QjtZQUM1RHdCLGVBQWUsT0FBT3hCLFlBQVksV0FBV0EsUUFBUXlCLE1BQU0sR0FBR3pCO1lBQzlEMEIsYUFBYSxPQUFPMUIsWUFBWSxXQUFXQSxRQUFRMkIsSUFBSSxHQUFHM0I7UUFDOUQ7UUFDQSxJQUFJNEIsY0FBYzNCLFVBQVU1SDtRQUM1QixPQUFRVSxNQUFNOEksYUFBYSxDQUFDLE9BQU9qTCxTQUFTLENBQUMsR0FBR3NLLE1BQU07WUFBRW5CLE9BQU9uSixTQUFTQSxTQUFTLENBQUMsR0FBR2tMLE9BQU9DLFNBQVMsR0FBR2hDO1FBQU8sSUFDM0doSCxNQUFNOEksYUFBYSxDQUFDLE9BQU9qTCxTQUFTO1lBQUV3RCxXQUFXNkc7WUFBYyxlQUFlO1lBQVFsQixPQUFPbkosU0FBU0EsU0FBU0EsU0FBUyxDQUFDLEdBQUdrTCxPQUFPRSxNQUFNLEdBQUdGLE9BQU83QixTQUFTLEdBQUdrQjtRQUFjLEdBQUksT0FBT1MsZ0JBQWdCLFdBQ2xNO1lBQUVLLHlCQUF5QjtnQkFBRUMsUUFBUU4sY0FBYztZQUFTO1FBQUUsSUFDOUQ7WUFBRU8sVUFBVVA7UUFBWSxLQUM5QjdJLE1BQU04SSxhQUFhLENBQUMsWUFBWTtZQUFFTyxLQUFLLFNBQVVDLENBQUM7Z0JBQUksT0FBUTVILE1BQU1LLE1BQU0sR0FBR3VIO1lBQUk7WUFBR3RDLE9BQU9uSixTQUFTQSxTQUFTQSxTQUFTLENBQUMsR0FBR2tMLE9BQU9FLE1BQU0sR0FBR0YsT0FBT1EsUUFBUSxHQUFHbkI7WUFBZS9HLFdBQVdBLFlBQWErRixDQUFBQSxvQkFBb0IsSUFBSTdGLE1BQU0sQ0FBQzZGLHFCQUFxQixFQUFDO1lBQUlvQyxJQUFJckM7WUFBWTdILE9BQU9BO1lBQU9tSyxVQUFVLElBQUksQ0FBQy9DLGFBQWE7WUFBRTlCLFdBQVcsSUFBSSxDQUFDSixjQUFjO1lBQUVzRCxTQUFTQTtZQUFTRyxTQUFTQTtZQUFTRixTQUFTQTtZQUFTQyxRQUFRQTtZQUFRVixVQUFVQTtZQUFVQyxNQUFNQTtZQUFNQyxXQUFXQTtZQUFXQyxXQUFXQTtZQUFXQyxNQUFNQTtZQUFNQyxhQUFhQTtZQUFhQyxVQUFVQTtZQUFVQyxVQUFVQTtZQUFVUixXQUFXQTtZQUFXcUMsZ0JBQWdCO1lBQU9DLGNBQWM7WUFBT0MsYUFBYTtZQUFPQyxZQUFZO1lBQU8sY0FBYztRQUFNLElBQ3JyQjdKLE1BQU04SSxhQUFhLENBQUMsU0FBUztZQUFFSSx5QkFBeUI7Z0JBQUVDLFFBQVE3SDtZQUFRO1FBQUU7SUFDcEY7SUFDQUUsT0FBT3NJLFlBQVksR0FBRztRQUNsQnJGLFNBQVM7UUFDVEMsY0FBYztRQUNkQyxjQUFjO1FBQ2RzQyxTQUFTO0lBQ2I7SUFDQSxPQUFPekY7QUFDWCxFQUFFeEIsTUFBTStKLFNBQVM7QUFDakJoSyxrQkFBZSxHQUFHeUI7QUFDbEIsSUFBSXVILFNBQVM7SUFDVEMsV0FBVztRQUNQM0csVUFBVTtRQUNWNEgsV0FBVztRQUNYQyxXQUFXO1FBQ1hqRCxTQUFTO1FBQ1RrRCxVQUFVO0lBQ2Q7SUFDQVosVUFBVTtRQUNObEgsVUFBVTtRQUNWaUcsS0FBSztRQUNMTSxNQUFNO1FBQ053QixRQUFRO1FBQ1JDLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BKLFVBQVU7UUFDVksscUJBQXFCO1FBQ3JCQyxxQkFBcUI7UUFDckJDLHFCQUFxQjtJQUN6QjtJQUNBeEQsV0FBVztRQUNQN0UsVUFBVTtRQUNWc0ksZUFBZTtJQUNuQjtJQUNBMUIsUUFBUTtRQUNKMkIsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLFlBQVk7UUFDWlosV0FBVztRQUNYYSxTQUFTO1FBQ1RDLFlBQVk7UUFDWkMsVUFBVTtRQUNWQyxXQUFXO1FBQ1hDLHNCQUFzQjtRQUN0QkMsWUFBWTtRQUNaQyxlQUFlO1FBQ2ZDLFlBQVk7UUFDWjdHLFNBQVM7UUFDVDhHLFlBQVk7UUFDWkMsZUFBZTtRQUNmQyxlQUFlO1FBQ2ZDLFlBQVk7UUFDWkMsV0FBVztRQUNYQyxjQUFjO0lBQ2xCO0FBQ0osR0FDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS10ZXN0LWdlbmVyYXRvci8uL25vZGVfbW9kdWxlcy9yZWFjdC1zaW1wbGUtY29kZS1lZGl0b3IvbGliL2luZGV4LmpzP2JmNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgS0VZQ09ERV9FTlRFUiA9IDEzO1xudmFyIEtFWUNPREVfVEFCID0gOTtcbnZhciBLRVlDT0RFX0JBQ0tTUEFDRSA9IDg7XG52YXIgS0VZQ09ERV9ZID0gODk7XG52YXIgS0VZQ09ERV9aID0gOTA7XG52YXIgS0VZQ09ERV9NID0gNzc7XG52YXIgS0VZQ09ERV9QQVJFTlMgPSA1NztcbnZhciBLRVlDT0RFX0JSQUNLRVRTID0gMjE5O1xudmFyIEtFWUNPREVfUVVPVEUgPSAyMjI7XG52YXIgS0VZQ09ERV9CQUNLX1FVT1RFID0gMTkyO1xudmFyIEtFWUNPREVfRVNDQVBFID0gMjc7XG52YXIgSElTVE9SWV9MSU1JVCA9IDEwMDtcbnZhciBISVNUT1JZX1RJTUVfR0FQID0gMzAwMDtcbnZhciBpc1dpbmRvd3MgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICduYXZpZ2F0b3InIGluIHdpbmRvdyAmJlxuICAgIC9XaW4vaS50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG52YXIgaXNNYWNMaWtlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAnbmF2aWdhdG9yJyBpbiB3aW5kb3cgJiZcbiAgICAvKE1hY3xpUGhvbmV8aVBvZHxpUGFkKS9pLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbnZhciBjbGFzc05hbWUgPSAnbnBtX19yZWFjdC1zaW1wbGUtY29kZS1lZGl0b3JfX3RleHRhcmVhJztcbnZhciBjc3NUZXh0ID0gLyogQ1NTICovIFwiXFxuLyoqXFxuICogUmVzZXQgdGhlIHRleHQgZmlsbCBjb2xvciBzbyB0aGF0IHBsYWNlaG9sZGVyIGlzIHZpc2libGVcXG4gKi9cXG4uXCIuY29uY2F0KGNsYXNzTmFtZSwgXCI6ZW1wdHkge1xcbiAgLXdlYmtpdC10ZXh0LWZpbGwtY29sb3I6IGluaGVyaXQgIWltcG9ydGFudDtcXG59XFxuXFxuLyoqXFxuICogSGFjayB0byBhcHBseSBvbiBzb21lIENTUyBvbiBJRTEwIGFuZCBJRTExXFxuICovXFxuQG1lZGlhIGFsbCBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OiBub25lKSwgKC1tcy1oaWdoLWNvbnRyYXN0OiBhY3RpdmUpIHtcXG4gIC8qKlxcbiAgICAqIElFIGRvZXNuJ3Qgc3VwcG9ydCAnLXdlYmtpdC10ZXh0LWZpbGwtY29sb3InXFxuICAgICogU28gd2UgdXNlICdjb2xvcjogdHJhbnNwYXJlbnQnIHRvIG1ha2UgdGhlIHRleHQgdHJhbnNwYXJlbnQgb24gSUVcXG4gICAgKiBVbmxpa2Ugb3RoZXIgYnJvd3NlcnMsIGl0IGRvZXNuJ3QgYWZmZWN0IGNhcmV0IGNvbG9yIGluIElFXFxuICAgICovXFxuICAuXCIpLmNvbmNhdChjbGFzc05hbWUsIFwiIHtcXG4gICAgY29sb3I6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XFxuICB9XFxuXFxuICAuXCIpLmNvbmNhdChjbGFzc05hbWUsIFwiOjpzZWxlY3Rpb24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYWNjZWY3ICFpbXBvcnRhbnQ7XFxuICAgIGNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcbiAgfVxcbn1cXG5cIik7XG52YXIgRWRpdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFZGl0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWRpdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fcmVjb3JkQ3VycmVudFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gX3RoaXMuX2lucHV0O1xuICAgICAgICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBTYXZlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGlucHV0XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpbnB1dC52YWx1ZSwgc2VsZWN0aW9uU3RhcnQgPSBpbnB1dC5zZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kID0gaW5wdXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgX3RoaXMuX3JlY29yZENoYW5nZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHNlbGVjdGlvbkVuZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fZ2V0TGluZXMgPSBmdW5jdGlvbiAodGV4dCwgcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZygwLCBwb3NpdGlvbikuc3BsaXQoJ1xcbicpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fcmVjb3JkQ2hhbmdlID0gZnVuY3Rpb24gKHJlY29yZCwgb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGlmIChvdmVyd3JpdGUgPT09IHZvaWQgMCkgeyBvdmVyd3JpdGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIF9kID0gX3RoaXMuX2hpc3RvcnksIHN0YWNrID0gX2Quc3RhY2ssIG9mZnNldCA9IF9kLm9mZnNldDtcbiAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJiYgb2Zmc2V0ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHNvbWV0aGluZyB1cGRhdGVzLCBkcm9wIHRoZSByZWRvIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICBfdGhpcy5faGlzdG9yeS5zdGFjayA9IHN0YWNrLnNsaWNlKDAsIG9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgIC8vIExpbWl0IHRoZSBudW1iZXIgb2Ygb3BlcmF0aW9ucyB0byAxMDBcbiAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBfdGhpcy5faGlzdG9yeS5zdGFjay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gSElTVE9SWV9MSU1JVCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmFzID0gY291bnQgLSBISVNUT1JZX0xJTUlUO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGlzdG9yeS5zdGFjayA9IHN0YWNrLnNsaWNlKGV4dHJhcywgY291bnQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGlzdG9yeS5vZmZzZXQgPSBNYXRoLm1heChfdGhpcy5faGlzdG9yeS5vZmZzZXQgLSBleHRyYXMsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gX3RoaXMuX2hpc3Rvcnkuc3RhY2tbX3RoaXMuX2hpc3Rvcnkub2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiB0aW1lc3RhbXAgLSBsYXN0LnRpbWVzdGFtcCA8IEhJU1RPUllfVElNRV9HQVApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBwcmV2aW91cyBlbnRyeSBleGlzdHMgYW5kIHdhcyBpbiBzaG9ydCBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCB0aGUgbGFzdCB3b3JkIGluIHRoZSBsaW5lXG4gICAgICAgICAgICAgICAgICAgIHZhciByZSA9IC9bXmEtejAtOV0oW2EtejAtOV0rKSQvaTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwcmV2aW91cyBsaW5lXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IChfYSA9IF90aGlzLl9nZXRMaW5lcyhsYXN0LnZhbHVlLCBsYXN0LnNlbGVjdGlvblN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnBvcCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF0Y2gocmUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IChfYiA9IF90aGlzLl9nZXRMaW5lcyhyZWNvcmQudmFsdWUsIHJlY29yZC5zZWxlY3Rpb25TdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wb3AoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hdGNoKHJlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcmV2aW91cyA9PT0gbnVsbCB8fCBwcmV2aW91cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldmlvdXNbMV0pICYmICgoX2MgPSBjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRbMV0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zdGFydHNXaXRoKHByZXZpb3VzWzFdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsYXN0IHdvcmQgb2YgdGhlIHByZXZpb3VzIGxpbmUgYW5kIGN1cnJlbnQgbGluZSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcndyaXRlIHByZXZpb3VzIGVudHJ5IHNvIHRoYXQgdW5kbyB3aWxsIHJlbW92ZSB3aG9sZSB3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGlzdG9yeS5zdGFja1tfdGhpcy5faGlzdG9yeS5vZmZzZXRdID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlY29yZCksIHsgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBvcGVyYXRpb24gdG8gdGhlIHN0YWNrXG4gICAgICAgICAgICBfdGhpcy5faGlzdG9yeS5zdGFjay5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCByZWNvcmQpLCB7IHRpbWVzdGFtcDogdGltZXN0YW1wIH0pKTtcbiAgICAgICAgICAgIF90aGlzLl9oaXN0b3J5Lm9mZnNldCsrO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fdXBkYXRlSW5wdXQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBfdGhpcy5faW5wdXQ7XG4gICAgICAgICAgICBpZiAoIWlucHV0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2YWx1ZXMgYW5kIHNlbGVjdGlvbiBzdGF0ZVxuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSByZWNvcmQudmFsdWU7XG4gICAgICAgICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHJlY29yZC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IHJlY29yZC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vblZhbHVlQ2hhbmdlKHJlY29yZC52YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9hcHBseUVkaXRzID0gZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgLy8gU2F2ZSBsYXN0IHNlbGVjdGlvbiBzdGF0ZVxuICAgICAgICAgICAgdmFyIGlucHV0ID0gX3RoaXMuX2lucHV0O1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBfdGhpcy5faGlzdG9yeS5zdGFja1tfdGhpcy5faGlzdG9yeS5vZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGxhc3QgJiYgaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGlzdG9yeS5zdGFja1tfdGhpcy5faGlzdG9yeS5vZmZzZXRdID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGxhc3QpLCB7IHNlbGVjdGlvblN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kOiBpbnB1dC5zZWxlY3Rpb25FbmQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjaGFuZ2VzXG4gICAgICAgICAgICBfdGhpcy5fcmVjb3JkQ2hhbmdlKHJlY29yZCk7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlSW5wdXQocmVjb3JkKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX3VuZG9FZGl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuX2hpc3RvcnksIHN0YWNrID0gX2Euc3RhY2ssIG9mZnNldCA9IF9hLm9mZnNldDtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcHJldmlvdXMgZWRpdFxuICAgICAgICAgICAgdmFyIHJlY29yZCA9IHN0YWNrW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBjaGFuZ2VzIGFuZCB1cGRhdGUgdGhlIG9mZnNldFxuICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVJbnB1dChyZWNvcmQpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9oaXN0b3J5Lm9mZnNldCA9IE1hdGgubWF4KG9mZnNldCAtIDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fcmVkb0VkaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5faGlzdG9yeSwgc3RhY2sgPSBfYS5zdGFjaywgb2Zmc2V0ID0gX2Eub2Zmc2V0O1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGVkaXRcbiAgICAgICAgICAgIHZhciByZWNvcmQgPSBzdGFja1tvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgY2hhbmdlcyBhbmQgdXBkYXRlIHRoZSBvZmZzZXRcbiAgICAgICAgICAgICAgICBfdGhpcy5fdXBkYXRlSW5wdXQocmVjb3JkKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGlzdG9yeS5vZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQgKyAxLCBzdGFjay5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX2hhbmRsZUtleURvd24gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIHRhYlNpemUgPSBfYS50YWJTaXplLCBpbnNlcnRTcGFjZXMgPSBfYS5pbnNlcnRTcGFjZXMsIGlnbm9yZVRhYktleSA9IF9hLmlnbm9yZVRhYktleSwgb25LZXlEb3duID0gX2Eub25LZXlEb3duO1xuICAgICAgICAgICAgaWYgKG9uS2V5RG93bikge1xuICAgICAgICAgICAgICAgIG9uS2V5RG93bihlKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFX0VTQ0FQRSkge1xuICAgICAgICAgICAgICAgIGUuY3VycmVudFRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBlLmN1cnJlbnRUYXJnZXQsIHZhbHVlID0gX2IudmFsdWUsIHNlbGVjdGlvblN0YXJ0ID0gX2Iuc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCA9IF9iLnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHZhciB0YWJDaGFyYWN0ZXIgPSAoaW5zZXJ0U3BhY2VzID8gJyAnIDogJ1xcdCcpLnJlcGVhdCh0YWJTaXplKTtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREVfVEFCICYmICFpZ25vcmVUYWJLZXkgJiYgX3RoaXMuc3RhdGUuY2FwdHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZm9jdXMgY2hhbmdlXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuaW5kZW50IHNlbGVjdGVkIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lc0JlZm9yZUNhcmV0ID0gX3RoaXMuX2dldExpbmVzKHZhbHVlLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydExpbmVfMSA9IGxpbmVzQmVmb3JlQ2FyZXQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZExpbmVfMSA9IF90aGlzLl9nZXRMaW5lcyh2YWx1ZSwgc2VsZWN0aW9uRW5kKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID49IHN0YXJ0TGluZV8xICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA8PSBlbmRMaW5lXzEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lLnN0YXJ0c1dpdGgodGFiQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lLnN1YnN0cmluZyh0YWJDaGFyYWN0ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGluZVRleHQgPSBsaW5lc0JlZm9yZUNhcmV0W3N0YXJ0TGluZV8xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hcHBseUVkaXRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV4dFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHN0YXJ0IGN1cnNvciBpZiBmaXJzdCBsaW5lIGluIHNlbGVjdGlvbiB3YXMgbW9kaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCB3YXMgbW9kaWZpZWQgb25seSBpZiBpdCBzdGFydGVkIHdpdGggYSB0YWJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogKHN0YXJ0TGluZVRleHQgPT09IG51bGwgfHwgc3RhcnRMaW5lVGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhcnRMaW5lVGV4dC5zdGFydHNXaXRoKHRhYkNoYXJhY3RlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZWN0aW9uU3RhcnQgLSB0YWJDaGFyYWN0ZXIubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgZW5kIGN1cnNvciBieSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiBzZWxlY3Rpb25FbmQgLSAodmFsdWUubGVuZ3RoIC0gbmV4dFZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGVudCBzZWxlY3RlZCBsaW5lc1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZXNCZWZvcmVDYXJldCA9IF90aGlzLl9nZXRMaW5lcyh2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnRMaW5lXzIgPSBsaW5lc0JlZm9yZUNhcmV0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmRMaW5lXzIgPSBfdGhpcy5fZ2V0TGluZXModmFsdWUsIHNlbGVjdGlvbkVuZCkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0TGluZVRleHQgPSBsaW5lc0JlZm9yZUNhcmV0W3N0YXJ0TGluZV8yXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGx5RWRpdHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBzdGFydExpbmVfMiAmJiBpIDw9IGVuZExpbmVfMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFiQ2hhcmFjdGVyICsgbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHN0YXJ0IGN1cnNvciBieSBudW1iZXIgb2YgY2hhcmFjdGVycyBhZGRlZCBpbiBmaXJzdCBsaW5lIG9mIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgbW92ZSBpdCBpZiBpdCB0aGVyZSB3YXMgbm8gdGV4dCBiZWZvcmUgY3Vyc29yXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogc3RhcnRMaW5lVGV4dCAmJiAvXFxTLy50ZXN0KHN0YXJ0TGluZVRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxlY3Rpb25TdGFydCArIHRhYkNoYXJhY3Rlci5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgZW5kIGN1cnNvciBieSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBhZGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiBzZWxlY3Rpb25FbmQgKyB0YWJDaGFyYWN0ZXIubGVuZ3RoICogKGVuZExpbmVfMiAtIHN0YXJ0TGluZV8yICsgMSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRTZWxlY3Rpb24gPSBzZWxlY3Rpb25TdGFydCArIHRhYkNoYXJhY3Rlci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hcHBseUVkaXRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCB0YWIgY2hhcmFjdGVyIGF0IGNhcmV0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFiQ2hhcmFjdGVyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjYXJldCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHVwZGF0ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHVwZGF0ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9CQUNLU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzU2VsZWN0aW9uID0gc2VsZWN0aW9uU3RhcnQgIT09IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dEJlZm9yZUNhcmV0ID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dEJlZm9yZUNhcmV0LmVuZHNXaXRoKHRhYkNoYXJhY3RlcikgJiYgIWhhc1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgZGVsZXRlIGJlaGF2aW91clxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkU2VsZWN0aW9uID0gc2VsZWN0aW9uU3RhcnQgLSB0YWJDaGFyYWN0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlFZGl0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGFiIGNoYXJhY3RlciBhdCBjYXJldFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCAtIHRhYkNoYXJhY3Rlci5sZW5ndGgpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjYXJldCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHVwZGF0ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHVwZGF0ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9FTlRFUikge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBzZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBfdGhpcy5fZ2V0TGluZXModmFsdWUsIHNlbGVjdGlvblN0YXJ0KS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBsaW5lID09PSBudWxsIHx8IGxpbmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmUubWF0Y2goL15cXHMrLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsIHx8IG1hdGNoZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdGNoZXNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIGluZGVudGF0aW9uIG9uIGluc2VydGluZyBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZW50ID0gJ1xcbicgKyBtYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZWRTZWxlY3Rpb24gPSBzZWxlY3Rpb25TdGFydCArIGluZGVudC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlFZGl0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGluZGVudGF0aW9uIGNoYXJhY3RlciBhdCBjYXJldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyaW5nKHNlbGVjdGlvbkVuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHVwZGF0ZWRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiB1cGRhdGVkU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT09IEtFWUNPREVfUEFSRU5TIHx8XG4gICAgICAgICAgICAgICAgZS5rZXlDb2RlID09PSBLRVlDT0RFX0JSQUNLRVRTIHx8XG4gICAgICAgICAgICAgICAgZS5rZXlDb2RlID09PSBLRVlDT0RFX1FVT1RFIHx8XG4gICAgICAgICAgICAgICAgZS5rZXlDb2RlID09PSBLRVlDT0RFX0JBQ0tfUVVPVEUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhcnMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9QQVJFTlMgJiYgZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFycyA9IFsnKCcsICcpJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9CUkFDS0VUUykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSBbJ3snLCAnfSddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSBbJ1snLCAnXSddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9RVU9URSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnMgPSBbJ1wiJywgJ1wiJ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFycyA9IFtcIidcIiwgXCInXCJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gS0VZQ09ERV9CQUNLX1FVT1RFICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzID0gWydgJywgJ2AnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGV4dCBpcyBzZWxlY3RlZCwgd3JhcCB0aGVtIGluIHRoZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQgJiYgY2hhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwbHlFZGl0cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnNbMF0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnNbMV0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25FbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNhcmV0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydDogc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHNlbGVjdGlvbkVuZCArIDIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChpc01hY0xpa2VcbiAgICAgICAgICAgICAgICA/IC8vIFRyaWdnZXIgdW5kbyB3aXRoIOKMmCtaIG9uIE1hY1xuICAgICAgICAgICAgICAgICAgICBlLm1ldGFLZXkgJiYgZS5rZXlDb2RlID09PSBLRVlDT0RFX1pcbiAgICAgICAgICAgICAgICA6IC8vIFRyaWdnZXIgdW5kbyB3aXRoIEN0cmwrWiBvbiBvdGhlciBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICAgICAgZS5jdHJsS2V5ICYmIGUua2V5Q29kZSA9PT0gS0VZQ09ERV9aKSAmJlxuICAgICAgICAgICAgICAgICFlLnNoaWZ0S2V5ICYmXG4gICAgICAgICAgICAgICAgIWUuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl91bmRvRWRpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGlzTWFjTGlrZVxuICAgICAgICAgICAgICAgID8gLy8gVHJpZ2dlciByZWRvIHdpdGgg4oyYK1NoaWZ0K1ogb24gTWFjXG4gICAgICAgICAgICAgICAgICAgIGUubWV0YUtleSAmJiBlLmtleUNvZGUgPT09IEtFWUNPREVfWiAmJiBlLnNoaWZ0S2V5XG4gICAgICAgICAgICAgICAgOiBpc1dpbmRvd3NcbiAgICAgICAgICAgICAgICAgICAgPyAvLyBUcmlnZ2VyIHJlZG8gd2l0aCBDdHJsK1kgb24gV2luZG93c1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5jdHJsS2V5ICYmIGUua2V5Q29kZSA9PT0gS0VZQ09ERV9ZXG4gICAgICAgICAgICAgICAgICAgIDogLy8gVHJpZ2dlciByZWRvIHdpdGggQ3RybCtTaGlmdCtaIG9uIG90aGVyIHBsYXRmb3Jtc1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5jdHJsS2V5ICYmIGUua2V5Q29kZSA9PT0gS0VZQ09ERV9aICYmIGUuc2hpZnRLZXkpICYmXG4gICAgICAgICAgICAgICAgIWUuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZWRvRWRpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXlDb2RlID09PSBLRVlDT0RFX00gJiZcbiAgICAgICAgICAgICAgICBlLmN0cmxLZXkgJiZcbiAgICAgICAgICAgICAgICAoaXNNYWNMaWtlID8gZS5zaGlmdEtleSA6IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSBjYXB0dXJpbmcgdGFiIGtleSBzbyB1c2VycyBjYW4gZm9jdXMgYXdheVxuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZTogIXN0YXRlLmNhcHR1cmUsXG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5faGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGUuY3VycmVudFRhcmdldCwgdmFsdWUgPSBfYS52YWx1ZSwgc2VsZWN0aW9uU3RhcnQgPSBfYS5zZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kID0gX2Euc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgX3RoaXMuX3JlY29yZENoYW5nZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQ6IHNlbGVjdGlvbkVuZCxcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25WYWx1ZUNoYW5nZSh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9oaXN0b3J5ID0ge1xuICAgICAgICAgICAgc3RhY2s6IFtdLFxuICAgICAgICAgICAgb2Zmc2V0OiAtMSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX2lucHV0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFZGl0b3IucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZWNvcmRDdXJyZW50U3RhdGUoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZGl0b3IucHJvdG90eXBlLCBcInNlc3Npb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGlzdG9yeTogdGhpcy5faGlzdG9yeSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkgPSBzZXNzaW9uLmhpc3Rvcnk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBFZGl0b3IucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgdmFsdWUgPSBfYS52YWx1ZSwgc3R5bGUgPSBfYS5zdHlsZSwgcGFkZGluZyA9IF9hLnBhZGRpbmcsIGhpZ2hsaWdodCA9IF9hLmhpZ2hsaWdodCwgdGV4dGFyZWFJZCA9IF9hLnRleHRhcmVhSWQsIHRleHRhcmVhQ2xhc3NOYW1lID0gX2EudGV4dGFyZWFDbGFzc05hbWUsIGF1dG9Gb2N1cyA9IF9hLmF1dG9Gb2N1cywgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgZm9ybSA9IF9hLmZvcm0sIG1heExlbmd0aCA9IF9hLm1heExlbmd0aCwgbWluTGVuZ3RoID0gX2EubWluTGVuZ3RoLCBuYW1lID0gX2EubmFtZSwgcGxhY2Vob2xkZXIgPSBfYS5wbGFjZWhvbGRlciwgcmVhZE9ubHkgPSBfYS5yZWFkT25seSwgcmVxdWlyZWQgPSBfYS5yZXF1aXJlZCwgb25DbGljayA9IF9hLm9uQ2xpY2ssIG9uRm9jdXMgPSBfYS5vbkZvY3VzLCBvbkJsdXIgPSBfYS5vbkJsdXIsIG9uS2V5VXAgPSBfYS5vbktleVVwLCBcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgICAgIG9uS2V5RG93biA9IF9hLm9uS2V5RG93biwgb25WYWx1ZUNoYW5nZSA9IF9hLm9uVmFsdWVDaGFuZ2UsIHRhYlNpemUgPSBfYS50YWJTaXplLCBpbnNlcnRTcGFjZXMgPSBfYS5pbnNlcnRTcGFjZXMsIGlnbm9yZVRhYktleSA9IF9hLmlnbm9yZVRhYktleSwgXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgICAgIHByZUNsYXNzTmFtZSA9IF9hLnByZUNsYXNzTmFtZSwgcmVzdCA9IF9fcmVzdChfYSwgW1widmFsdWVcIiwgXCJzdHlsZVwiLCBcInBhZGRpbmdcIiwgXCJoaWdobGlnaHRcIiwgXCJ0ZXh0YXJlYUlkXCIsIFwidGV4dGFyZWFDbGFzc05hbWVcIiwgXCJhdXRvRm9jdXNcIiwgXCJkaXNhYmxlZFwiLCBcImZvcm1cIiwgXCJtYXhMZW5ndGhcIiwgXCJtaW5MZW5ndGhcIiwgXCJuYW1lXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJyZWFkT25seVwiLCBcInJlcXVpcmVkXCIsIFwib25DbGlja1wiLCBcIm9uRm9jdXNcIiwgXCJvbkJsdXJcIiwgXCJvbktleVVwXCIsIFwib25LZXlEb3duXCIsIFwib25WYWx1ZUNoYW5nZVwiLCBcInRhYlNpemVcIiwgXCJpbnNlcnRTcGFjZXNcIiwgXCJpZ25vcmVUYWJLZXlcIiwgXCJwcmVDbGFzc05hbWVcIl0pO1xuICAgICAgICB2YXIgY29udGVudFN0eWxlID0ge1xuICAgICAgICAgICAgcGFkZGluZ1RvcDogdHlwZW9mIHBhZGRpbmcgPT09ICdvYmplY3QnID8gcGFkZGluZy50b3AgOiBwYWRkaW5nLFxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiB0eXBlb2YgcGFkZGluZyA9PT0gJ29iamVjdCcgPyBwYWRkaW5nLnJpZ2h0IDogcGFkZGluZyxcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IHR5cGVvZiBwYWRkaW5nID09PSAnb2JqZWN0JyA/IHBhZGRpbmcuYm90dG9tIDogcGFkZGluZyxcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiB0eXBlb2YgcGFkZGluZyA9PT0gJ29iamVjdCcgPyBwYWRkaW5nLmxlZnQgOiBwYWRkaW5nLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBoaWdobGlnaHQodmFsdWUpO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHJlc3QsIHsgc3R5bGU6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdHlsZXMuY29udGFpbmVyKSwgc3R5bGUpIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCBfX2Fzc2lnbih7IGNsYXNzTmFtZTogcHJlQ2xhc3NOYW1lLCBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLCBzdHlsZTogX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlcy5lZGl0b3IpLCBzdHlsZXMuaGlnaGxpZ2h0KSwgY29udGVudFN0eWxlKSB9LCAodHlwZW9mIGhpZ2hsaWdodGVkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8geyBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IGhpZ2hsaWdodGVkICsgJzxiciAvPicgfSB9XG4gICAgICAgICAgICAgICAgOiB7IGNoaWxkcmVuOiBoaWdobGlnaHRlZCB9KSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIsIHsgcmVmOiBmdW5jdGlvbiAoYykgeyByZXR1cm4gKF90aGlzLl9pbnB1dCA9IGMpOyB9LCBzdHlsZTogX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlcy5lZGl0b3IpLCBzdHlsZXMudGV4dGFyZWEpLCBjb250ZW50U3R5bGUpLCBjbGFzc05hbWU6IGNsYXNzTmFtZSArICh0ZXh0YXJlYUNsYXNzTmFtZSA/IFwiIFwiLmNvbmNhdCh0ZXh0YXJlYUNsYXNzTmFtZSkgOiAnJyksIGlkOiB0ZXh0YXJlYUlkLCB2YWx1ZTogdmFsdWUsIG9uQ2hhbmdlOiB0aGlzLl9oYW5kbGVDaGFuZ2UsIG9uS2V5RG93bjogdGhpcy5faGFuZGxlS2V5RG93biwgb25DbGljazogb25DbGljaywgb25LZXlVcDogb25LZXlVcCwgb25Gb2N1czogb25Gb2N1cywgb25CbHVyOiBvbkJsdXIsIGRpc2FibGVkOiBkaXNhYmxlZCwgZm9ybTogZm9ybSwgbWF4TGVuZ3RoOiBtYXhMZW5ndGgsIG1pbkxlbmd0aDogbWluTGVuZ3RoLCBuYW1lOiBuYW1lLCBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsIHJlYWRPbmx5OiByZWFkT25seSwgcmVxdWlyZWQ6IHJlcXVpcmVkLCBhdXRvRm9jdXM6IGF1dG9Gb2N1cywgYXV0b0NhcGl0YWxpemU6IFwib2ZmXCIsIGF1dG9Db21wbGV0ZTogXCJvZmZcIiwgYXV0b0NvcnJlY3Q6IFwib2ZmXCIsIHNwZWxsQ2hlY2s6IGZhbHNlLCBcImRhdGEtZ3JhbW1cIjogZmFsc2UgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwgeyBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IGNzc1RleHQgfSB9KSkpO1xuICAgIH07XG4gICAgRWRpdG9yLmRlZmF1bHRQcm9wcyA9IHtcbiAgICAgICAgdGFiU2l6ZTogMixcbiAgICAgICAgaW5zZXJ0U3BhY2VzOiB0cnVlLFxuICAgICAgICBpZ25vcmVUYWJLZXk6IGZhbHNlLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgIH07XG4gICAgcmV0dXJuIEVkaXRvcjtcbn0oUmVhY3QuQ29tcG9uZW50KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFZGl0b3I7XG52YXIgc3R5bGVzID0ge1xuICAgIGNvbnRhaW5lcjoge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgfSxcbiAgICB0ZXh0YXJlYToge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgcmVzaXplOiAnbm9uZScsXG4gICAgICAgIGNvbG9yOiAnaW5oZXJpdCcsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgTW96T3N4Rm9udFNtb290aGluZzogJ2dyYXlzY2FsZScsXG4gICAgICAgIFdlYmtpdEZvbnRTbW9vdGhpbmc6ICdhbnRpYWxpYXNlZCcsXG4gICAgICAgIFdlYmtpdFRleHRGaWxsQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgfSxcbiAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICB9LFxuICAgIGVkaXRvcjoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICBib3hTaXppbmc6ICdpbmhlcml0JyxcbiAgICAgICAgZGlzcGxheTogJ2luaGVyaXQnLFxuICAgICAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgICAgIGZvbnRTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIGZvbnRTdHlsZTogJ2luaGVyaXQnLFxuICAgICAgICBmb250VmFyaWFudExpZ2F0dXJlczogJ2luaGVyaXQnLFxuICAgICAgICBmb250V2VpZ2h0OiAnaW5oZXJpdCcsXG4gICAgICAgIGxldHRlclNwYWNpbmc6ICdpbmhlcml0JyxcbiAgICAgICAgbGluZUhlaWdodDogJ2luaGVyaXQnLFxuICAgICAgICB0YWJTaXplOiAnaW5oZXJpdCcsXG4gICAgICAgIHRleHRJbmRlbnQ6ICdpbmhlcml0JyxcbiAgICAgICAgdGV4dFJlbmRlcmluZzogJ2luaGVyaXQnLFxuICAgICAgICB0ZXh0VHJhbnNmb3JtOiAnaW5oZXJpdCcsXG4gICAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAgIHdvcmRCcmVhazogJ2tlZXAtYWxsJyxcbiAgICAgICAgb3ZlcmZsb3dXcmFwOiAnYnJlYWstd29yZCcsXG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19leHRlbmRzIiwiZXh0ZW5kU3RhdGljcyIsImQiLCJiIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJBcnJheSIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJfXyIsImNvbnN0cnVjdG9yIiwiY3JlYXRlIiwiX19hc3NpZ24iLCJhc3NpZ24iLCJ0IiwicyIsImkiLCJuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXBwbHkiLCJfX2NyZWF0ZUJpbmRpbmciLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJfX3Jlc3QiLCJlIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZXhwb3J0cyIsIlJlYWN0IiwicmVxdWlyZSIsIktFWUNPREVfRU5URVIiLCJLRVlDT0RFX1RBQiIsIktFWUNPREVfQkFDS1NQQUNFIiwiS0VZQ09ERV9ZIiwiS0VZQ09ERV9aIiwiS0VZQ09ERV9NIiwiS0VZQ09ERV9QQVJFTlMiLCJLRVlDT0RFX0JSQUNLRVRTIiwiS0VZQ09ERV9RVU9URSIsIktFWUNPREVfQkFDS19RVU9URSIsIktFWUNPREVfRVNDQVBFIiwiSElTVE9SWV9MSU1JVCIsIkhJU1RPUllfVElNRV9HQVAiLCJpc1dpbmRvd3MiLCJ3aW5kb3ciLCJ0ZXN0IiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJpc01hY0xpa2UiLCJjbGFzc05hbWUiLCJjc3NUZXh0IiwiY29uY2F0IiwiRWRpdG9yIiwiX3N1cGVyIiwiX3RoaXMiLCJzdGF0ZSIsImNhcHR1cmUiLCJfcmVjb3JkQ3VycmVudFN0YXRlIiwiaW5wdXQiLCJfaW5wdXQiLCJzZWxlY3Rpb25TdGFydCIsInNlbGVjdGlvbkVuZCIsIl9yZWNvcmRDaGFuZ2UiLCJfZ2V0TGluZXMiLCJ0ZXh0IiwicG9zaXRpb24iLCJzdWJzdHJpbmciLCJzcGxpdCIsInJlY29yZCIsIm92ZXJ3cml0ZSIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX2hpc3RvcnkiLCJzdGFjayIsIm9mZnNldCIsInNsaWNlIiwiY291bnQiLCJleHRyYXMiLCJNYXRoIiwibWF4IiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImxhc3QiLCJyZSIsInByZXZpb3VzIiwicG9wIiwibWF0Y2giLCJjdXJyZW50Iiwic3RhcnRzV2l0aCIsInB1c2giLCJfdXBkYXRlSW5wdXQiLCJwcm9wcyIsIm9uVmFsdWVDaGFuZ2UiLCJfYXBwbHlFZGl0cyIsIl91bmRvRWRpdCIsIl9yZWRvRWRpdCIsIm1pbiIsIl9oYW5kbGVLZXlEb3duIiwidGFiU2l6ZSIsImluc2VydFNwYWNlcyIsImlnbm9yZVRhYktleSIsIm9uS2V5RG93biIsImRlZmF1bHRQcmV2ZW50ZWQiLCJrZXlDb2RlIiwiY3VycmVudFRhcmdldCIsImJsdXIiLCJ0YWJDaGFyYWN0ZXIiLCJyZXBlYXQiLCJwcmV2ZW50RGVmYXVsdCIsInNoaWZ0S2V5IiwibGluZXNCZWZvcmVDYXJldCIsInN0YXJ0TGluZV8xIiwiZW5kTGluZV8xIiwibmV4dFZhbHVlIiwibWFwIiwibGluZSIsImpvaW4iLCJzdGFydExpbmVUZXh0Iiwic3RhcnRMaW5lXzIiLCJlbmRMaW5lXzIiLCJ1cGRhdGVkU2VsZWN0aW9uIiwiaGFzU2VsZWN0aW9uIiwidGV4dEJlZm9yZUNhcmV0IiwiZW5kc1dpdGgiLCJtYXRjaGVzIiwiaW5kZW50IiwiY2hhcnMiLCJtZXRhS2V5IiwiY3RybEtleSIsImFsdEtleSIsInNldFN0YXRlIiwiX2hhbmRsZUNoYW5nZSIsImNvbXBvbmVudERpZE1vdW50IiwiaGlzdG9yeSIsInNldCIsInNlc3Npb24iLCJyZW5kZXIiLCJzdHlsZSIsInBhZGRpbmciLCJoaWdobGlnaHQiLCJ0ZXh0YXJlYUlkIiwidGV4dGFyZWFDbGFzc05hbWUiLCJhdXRvRm9jdXMiLCJkaXNhYmxlZCIsImZvcm0iLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJuYW1lIiwicGxhY2Vob2xkZXIiLCJyZWFkT25seSIsInJlcXVpcmVkIiwib25DbGljayIsIm9uRm9jdXMiLCJvbkJsdXIiLCJvbktleVVwIiwicHJlQ2xhc3NOYW1lIiwicmVzdCIsImNvbnRlbnRTdHlsZSIsInBhZGRpbmdUb3AiLCJ0b3AiLCJwYWRkaW5nUmlnaHQiLCJyaWdodCIsInBhZGRpbmdCb3R0b20iLCJib3R0b20iLCJwYWRkaW5nTGVmdCIsImxlZnQiLCJoaWdobGlnaHRlZCIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZXMiLCJjb250YWluZXIiLCJlZGl0b3IiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsImNoaWxkcmVuIiwicmVmIiwiYyIsInRleHRhcmVhIiwiaWQiLCJvbkNoYW5nZSIsImF1dG9DYXBpdGFsaXplIiwiYXV0b0NvbXBsZXRlIiwiYXV0b0NvcnJlY3QiLCJzcGVsbENoZWNrIiwiZGVmYXVsdFByb3BzIiwiQ29tcG9uZW50IiwiZGVmYXVsdCIsInRleHRBbGlnbiIsImJveFNpemluZyIsIm92ZXJmbG93IiwiaGVpZ2h0Iiwid2lkdGgiLCJyZXNpemUiLCJjb2xvciIsIk1vek9zeEZvbnRTbW9vdGhpbmciLCJXZWJraXRGb250U21vb3RoaW5nIiwiV2Via2l0VGV4dEZpbGxDb2xvciIsInBvaW50ZXJFdmVudHMiLCJtYXJnaW4iLCJib3JkZXIiLCJiYWNrZ3JvdW5kIiwiZGlzcGxheSIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsImZvbnRTdHlsZSIsImZvbnRWYXJpYW50TGlnYXR1cmVzIiwiZm9udFdlaWdodCIsImxldHRlclNwYWNpbmciLCJsaW5lSGVpZ2h0IiwidGV4dEluZGVudCIsInRleHRSZW5kZXJpbmciLCJ0ZXh0VHJhbnNmb3JtIiwid2hpdGVTcGFjZSIsIndvcmRCcmVhayIsIm92ZXJmbG93V3JhcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-simple-code-editor/lib/index.js\n");

/***/ })

};
;